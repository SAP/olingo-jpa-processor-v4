= What is the problem with In and Exist clauses

Sometimes you come across the need to find entries of a table that have a value in a column out of a list of provided values. SQL provides for this the option to use an IN expression within the WHERE condition. 

Lets have a look at the following small example:

[source,sql]
----
CREATE TABLE "Product"(
	"Id" INT NOT NULL,
	"CategoryName" VARCHAR(250) NOT NULL,
	"Color"  VARCHAR(250),
	"Size" INT,
	PRIMARY KEY ("Id"));
	
INSERT INTO "Product" VALUES (1, 'Shirt', 'blue', 1);
INSERT INTO "Product" VALUES (2, 'Trousers', 'blue', 2);
INSERT INTO "Product" VALUES (3, 'Shirt', 'white', 1);
INSERT INTO "Product" VALUES (4, 'Trousers', 'white', 2);
INSERT INTO "Product" VALUES (5, 'Shirt', 'red', 1);
----

So, there is a table "Product" with some columns, like the color of the product. Lets assume we like to read all the products that are either blue or white. The following SQL query would do the job:

[source,sql]
----
SELECT * 
    FROM "Product"
    WHERE "Color" IN ('blue', 'white')
----

Using JPA Criteria Builder, the necessary Java code to create this query would look like this:
[source,java]
----
final CriteriaQuery<Product> query = cb.createQuery(Product.class);//<1>
final Root<Product> product = query.from(Product.class);
query.select(product);
query.where(cb.in(product.get("color")).value("blue").value("white"));//<2>
final TypedQuery<Product> typedQuery = em.createQuery(query);
final List<Product> result = typedQuery.getResultList();
----
<1> Definition of the query that shall return products.  
<2> Definition of the IN clause. 

Lets assume there is another table that is used to group similar products into categories:

[source,sql]
----
CREATE TABLE "Category"(
	"Id" INT NOT NULL,
	"Name" VARCHAR(250) NOT NULL,
	PRIMARY KEY ("Id"));
	
INSERT INTO "Category" VALUES (1, 'Shirt');
INSERT INTO "Category" VALUES (2, 'Trousers');
----

If we want to know what category contains red products, we can not directly use the given value, we have to use a sub-query for products to find the corresponding categories:

[source,sql]
----
SELECT * 
    FROM "Category"
    WHERE "Name" IN (
        SELECT "CategoryName" 
            FROM "Product"
            WHERE "Color" = 'red')
----
The Java code becomes more complicated:

[source,java]
----
final CriteriaQuery<Category> query = cb.createQuery(Category.class);
final Root<Category> category = query.from(Category.class);
query.select(category);

final Subquery<String> subQuery = query.subquery(String.class); //<1>
final Root<Product> product = subQuery.from(Product.class);
subQuery.select(product.get("categoryName"));
subQuery.where(cb.equal(product.get("color"), "red"));
    
query.where(cb.in(category.get("name")).value(subQuery)); //<2>
final TypedQuery<Category> typedQuery = em.createQuery(query);
final List<Category> result = typedQuery.getResultList();
----

<1> Definition of the sub-query. It is important to notice the we have to give the "return type" of the sub-query here.
<2> Definition of the IN clause. This time we provide the sub-query as value. The type of the attribute has to be the same as the one of the sub-query.

Now we like to find all _blue shirts_ and _white trousers_. Unfortunately there is no IN, that takes a list of columns or to be more precise, it can take only one path. So we have to
fallback to a small tick. The properties for Color and CategoryName become an embeddable:

[source,java]
----
final CriteriaQuery<Product> query = cb.createQuery(Product.class);
final Root<Product> product = query.from(Product.class);
query.select(product);
query.where(cb.in(product.get("categorySize"))
   .value(new CategorySize("Shirt","blue"))
   .value(new CategorySize("Trousers","white")));
final TypedQuery<Product> typedQuery = em.createQuery(query);
final List<Product> result = typedQuery.getResultList();
----

[NOTE]
====
This code provided work well with Hibernate 6.4.0.Final. EclipsLink, version 4.0.1, 
only supports EmbeddedId in this case. At the time writing, OpenJPA has no version supporting 
JPA 3.x.
====

This solution has at least two drawbacks:
. As the Subquery interface only supports select, but not multiselect, using sub-queries would require a corresponding embeddable there as well
. Static criteria builder to generate queries e.g. basde on a REST call

So what options are left? For a given list of values we are at the end. The only thing that we can do is 
to fallback to a long list of AND and OR conditions:
[source,sql]
----
SELECT * 
    FROM "Product"
    WHERE ("Color" = 'blue' AND "CategoryName" = 'Shirt')
    OR    ("Color" =  'white' AND "CategoryName" = 'Trousers')  
----
And what about using sub-queries? EXISTS helps. 
 